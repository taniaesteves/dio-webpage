extends layout.pug

block navbar-options
    li.nav-item.active
        a.nav-link(href='/elasticsearch') Description
    li.nav-item
        a.nav-link(href='/elasticsearch/how2run') How to reproduce
    li.nav-item
        a.nav-link(href='/elasticsearch/portfolio') Portfolio

block content
    h2(style='text-align: center;') Elasticsearch use case

    p
        | This use case shows the exploratory capabilities of DIO to analyze the Elasticsearch application.
        | Namely, we used DIO to understand how Elasticsearch accesses the storage system.
        | Moreover, by following a top-down approach, we show how users can observe inefficient file access patterns.
        | <br>The instructions to reproduce the use case are available at
        a(href='/elasticsearch/how2run', target='_blank', style='color: blue;')  how to reproduce
        | , while an extendend set of visualizations provided by DIO are available at
        a(href='/elasticsearch/portfolio', target='_blank', style='color: blue;')  portfolio.

    h5 System overview
    p
        | Using DIO we observed that Elasticsearch generated about <code>1 million</code> storage-related system calls, <code>99%</code> of them targeting <code>regular files</code> and the remaining ones targeting directories.
        | Moreover, Elasticsearch uses mainly <code>data-related operations (88%)</code>, most of them being <code>write (71%)</code>, <code>pread64 (7%)</code> and <code>read (5%)</code>.
        | Further, it spawns a total of <code>42</code> processes and <code>118</code> threads, while accessing almost <code>4000</code> files.

    img(src="/image/elasticsearch/stats.png", alt="", style="width: 80%; text-align: center; display: block; margin-left: auto; margin-right: auto;")
    p(style="text-align: center") <em>Figure 1. System overview of Elasticsearch execution</em>

    h5 File access patterns
    p
        | By observing the file access patterns, DIO shows that some files exhibit a constant access pattern, even in the absence of client requests.
        | Namely, every <code>30</code> seconds Elasticsearch submits <code>2</code> system calls to the <code>node.lock</code> file (see Figure 2 - blue line).
        | Moreover, every <code>2</code> minutes, <code>10</code> system calls to <code>.es_temp_file</code> file (see Figure 2 - pink line).

    img(src="/image/elasticsearch/file_path_accesses.png", alt="", style="width: 70%; text-align: center; display: block; margin-left: auto; margin-right: auto;")
    p(style="text-align: center") <em>Figure 2. Sample of Elasticsearch file accesses</em>

    h5 File access pattern for <em>.es_temp_file</em>
    p
        | By analyzing in more detail the file access pattern for <code>.es_temp_file</code>, DIO shows that Elasticsearch performs always the same sequecence of system calls:
        | <code>lstat→openat→write→openat→fsync→close→close→lstat→unlink</code> (see Figure 3).

    img(src="/image/elasticsearch/es_temp_file_nano.png", alt="", style="width: 70%; text-align: center; display: block; margin-left: auto; margin-right: auto;")
    p(style="text-align: center") <em>Figure 3. File access pattern for .es_temp_file </em>

    p
        | <strong>Observation:</strong> this sequence of system calls shows an unexpected duplication of <code>openat</code> and <code>close</code> system calls.
        | <br><strong>Explanation:</strong> As show in Figure 4, Elasticsearch's Java source code used for accessing the .es_temp_file file resorts to high-level I/O libraries, which end up masking the underlying system calls and resulting in the duplication of system calls.

    img(src="/image/elasticsearch/es-alg.png", alt="", style="width: 50%; text-align: center; display: block; margin-left: auto; margin-right: auto;")
    p(style="text-align: center") <em>Figure 4. Mapping between system calls issued to .es_temp_file and corresponding code generating these.</em>

    ul
        li
            | The first openat is generated by the Files.newOutputStream method (
            span.whitecircle 1
            | ), which opens an output stream used for writing data to the file (
            span.whitecircle 2
            | ).
        li
            | An IOUtils.fsync method is then invoked to flush dirty pages to disk (
            span.whitecircle 3
            | ).
        li
            | However, rather than using the already opened file descriptor, created from the first openat call, it internally reopens and closes the file again.
        li
            | Finally, upon the file's removal request (
            span.whitecircle 4
            | ), three system calls are issued: a close corresponding to the first openat, a lstat, and an unlink.